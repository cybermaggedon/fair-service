#!/usr/bin/env python3

import http.server
import json
import pyfair
import io
import matplotlib.pyplot as plt
import pandas as pd
import urllib.parse as urlparse
import traceback

class Handler(http.server.BaseHTTPRequestHandler):

    # Returns list of models
    def load_model(self, spec, all):

        name = spec["name"]
        params = spec["parameters"]
        if "simulations" in spec:
            simul=int(spec["simulations"])
        else:
            simul=10000
            
        if type(params) == dict:

            model = pyfair.FairModel(name=name, n_simulations=simul)
            model.bulk_import_data(params)
            all.append(model)
            return model

        if type(params) == list:

            models = [
                self.load_model(m, all) for m in params
            ]
            metamodel = pyfair.FairMetaModel(name=name, models=models)
            all.append(metamodel)
            return metamodel

        raise RuntimeError("Bad model parameters")
    
    def distribution(self, model_spec):

        all = []
        model = self.load_model(model_spec, all)
        model.calculate_all()

        dc = pyfair.report.distribution.FairDistributionCurve(all)
        fig, ax = dc.generate_image()

        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        ilen = buf.tell()
        buf.seek(0)
        data = buf.read(ilen)

        return data, "image/png"

    def exceedence(self, model_spec):

        all = []
        model = self.load_model(model_spec, all)
        model.calculate_all()

        dc = pyfair.report.exceedence.FairExceedenceCurves(all)
        fig, ax = dc.generate_image()

        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        ilen = buf.tell()
        buf.seek(0)
        data = buf.read(ilen)

        return data, "image/png"

    def results(self, model_spec):

        all = []
        model = self.load_model(model_spec, all)
        model.calculate_all()

        results = model.export_results().T

        summary = pd.DataFrame({
            'mean': results.mean(axis=1), 
            'stdev': results.std(axis=1),
            'min': results.min(axis=1),
            'max': results.max(axis=1),
        })

        data = summary.to_json(indent=4).encode('utf-8')
        return data, "application/json"

    def __init__(self, request, client_address, server):
        super().__init__(request, client_address, server)

    def invoke(self, report, model):

        if report == "exceedence":
            data, type = self.exceedence(model)
        elif report == "distribution":
            data, type = self.distribution(model)
        elif report == "results":
            data, type = self.results(model)
        else:
            raise RuntimeError("Report %s not known" % report)
        
        self.send_response(200)
        self.send_header("Content-Length", len(data))
        self.send_header("Content-Type", type)
        self.end_headers()
        self.wfile.write(data)
        
    def do_GET(self):

        try:
            components = urlparse.urlparse(self.path)
            params = urlparse.parse_qs(components.query)
            report = params["report"][0]
            model = json.loads(params["model"][0])
            return self.invoke(report, model)

        except Exception as e:
            print(repr(e))

    def do_POST(self):

        try:
            content_length = int(self.headers['Content-Length'])
            data = self.rfile.read(content_length)
            params = json.loads(data)

            return self.invoke(params["report"], params["model"])

        except Exception as e:
            print(repr(e))

srv = http.server.HTTPServer(("", 8080), Handler)
srv.serve_forever()

